<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>SIYA Documentation</title>

  <!-- Styles: GitHub markdown + custom UI -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <!-- LaTeX rendering (full .tex documents) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/latex.js/dist/latex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/latex.js/dist/latex.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
  <!-- Keep KaTeX for Markdown inline math support -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}]});"></script>

  <style>
    #markdownContainer iframe {
      width: 100%;
      min-height: 600px;
      border: 1px solid #ddd;
      overflow: auto;
    }
    :root{
      --bg:#fdfdf7; --muted:#6b7280; --panel:#fdfdf7; --accent:#0a1121;
      --nav-text:#3e3e3e; --heading:#171717;
      --sidebar-w:300px; --radius:10px; --gap:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;color:var(--text,#0f1724);background:var(--bg)}

    /* App layout */
    .app{display:flex;height:100vh;}
    .sidebar{width:var(--sidebar-w);background:var(--bg);border-right:1px solid #e6eef8;display:flex;flex-direction:column}
    .sidebar .brand{padding:16px 20px;border-bottom:1px solid #eef2ff;display:flex;align-items:center;gap:10px;justify-content:space-between}
    .sidebar .brand-left{display:flex;align-items:center;gap:10px;min-width:0}
    .sidebar .brand a{display:flex;align-items:center;gap:10px;color:inherit;text-decoration:none}
    .brand img.logo{height:22px;width:auto;display:block}
    .brand h1{margin:0;font-size:16px;white-space:nowrap}
    .brand .hamburger{margin-left:auto;padding:6px 10px;border-radius:10px;border:1px solid #e6eef8;background:var(--panel);cursor:pointer;line-height:1;display:flex;align-items:center;justify-content:center;width:36px;height:34px}
    .brand .hamburger:hover{background:#eef2ff}
    .brand .hamburger:focus{outline:none;box-shadow:0 0 0 2px rgba(59,130,246,.35)}
    .sidebar .controls{padding:12px 16px;border-bottom:1px solid #fdfdf7;display:flex;gap:8px;align-items:center}
    .search{flex:1}
    .search input{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #e6eef8}
    .toggle-btn{padding:6px 10px;border-radius:8px;border:1px solid #e6eef8;background:var(--panel);cursor:pointer}
    .toggle-btn.copied{background:#10b981;border-color:#10b981;color:#ffffff}

    .nav{flex:1;overflow:auto;padding:12px 8px}
    .nav .section-title{font-size:12px;color:var(--muted);margin:12px 12px 6px}
    .nav a{display:block;padding:10px 16px;border-radius:8px;color:var(--nav-text);text-decoration:none;margin:6px 8px;font-size:15px;font-family: Styrene, Inter, ui-sans-serif, system-ui, -apple-system}
    .nav a.active {
      background-color: #e5e7eb;
      color: #111;
      border-left: 3px solid var(--accent);
      font-weight: 600;
    }
    .sidebar a {
      font-size: 13px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.4;
      padding: 4px 8px;
      display: block;
      color: #374151;
      text-decoration: none;
      font-weight: 600;
    }
    .sidebar a:hover {
      background-color: #f3f4f6;
    }
    .sidebar a.active {
      background-color: #e5e7eb;
      font-weight: 700;
    }
    .nav .folder-block{margin:6px 0}
    .nav .folder-row{display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:8px;margin:6px 8px;user-select:none;justify-content:flex-start;background:var(--panel)}
.nav .folder-row .caret{cursor:pointer;padding:4px 8px;}
    .nav .folder-row:hover{background:#f8fafc}
    .nav .caret:hover{background:#fdfdf7}
    .nav .folder-title{font-weight:600;color:var(--nav-text);font-size:14.5px;font-family: Styrene, Inter, ui-sans-serif, system-ui, -apple-system}
    .nav .caret{transition:transform .15s ease;color:#9aa4b2;margin-left:8px;cursor:pointer;width:24px;text-align:center;border-radius:4px;padding:2px}
    .nav .folder-row.collapsed .caret{transform:rotate(90deg)}
    .nav .children{margin-left:12px}
    .nav .indent-1 a{margin-left:16px}
    .nav .indent-2 a{margin-left:32px}
    .nav .indent-3 a{margin-left:48px}

    /* sidebar collapse */
    .app.collapsed .sidebar{width:64px}
    .app.collapsed .nav{display:none}
    .app.collapsed .brand{flex-direction:column; align-items:center; justify-content:center; gap:6px}
    .app.collapsed .brand-left h1{display:none}
    .app.collapsed .brand .hamburger{margin-left:0; width:36px; height:32px; padding:6px 8px}
    .app.collapsed .sidebar{border-right-color:#e6eef8}

    /* Main area */
    .main{flex:1;display:flex;flex-direction:column;overflow:hidden}
    .topbar{display:flex;justify-content:space-between;align-items:center;padding:14px 22px;border-bottom:1px solid #eef2ff;background:linear-gradient(180deg,#fdfdf7,#fdfdf7)}
    .topbar .left-actions{display:flex;align-items:center;gap:10px}
    .topbar .title{font-weight:600;color:var(--heading)}
    .topbar .crumb{margin-left:10px;color:var(--muted);font-size:13px}
    .topbar .meta{color:var(--muted);font-size:13px}
    .topbar .actions{display:flex;gap:8px;align-items:center}
    .top-search{flex:1;display:flex;justify-content:center;margin:0 16px}
    .top-search .searchbox{position:relative;max-width:560px;flex:1}
    .top-search input{width:100%;padding:10px 34px 10px 36px;border-radius:999px;border:1px solid #e6eef8;background:var(--panel)}
    .top-search .icon{position:absolute;left:12px;top:50%;transform:translateY(-50%);color:#9aa4b2}
    .top-search .kbd{position:absolute;right:10px;top:50%;transform:translateY(-50%);font-size:12px;color:#9aa4b2}

    .container{display:flex;gap:24px;padding:22px;overflow:auto}
    .app.collapsed .container{padding-left:22px}
    .content{flex:1;max-width:980px}
    .panel{background:var(--panel);padding:28px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(17,24,39,0.04)}

    /* small utility classes replacing inline styles */
    .repo-footer{padding:12px;border-top:1px solid #fdfdf7;font-size:12px;color:var(--muted)}
    .open-on-git{font-size:13px;color:var(--accent);text-decoration:none}
    .toc-inner{position:sticky;top:22px;padding:12px}
    /* doc actions inside panel */
    .doc-actions{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:10px}
    .folder-display{font-weight:600;color:var(--heading);font-size:15px}
    .pdf-frame{width:100%;height:82vh;border:1px solid #e6eef8;border-radius:8px}
    /* search modal styles */
    .search-modal{position:fixed;inset:0;background:rgba(15,23,42,0.45);z-index:50}
    .search-panel{max-width:720px;margin:10vh auto;padding:18px}
    .top-search{flex:1;display:flex;justify-content:center;margin:0 16px}
    .top-search .searchbox.full{width:100%}
    .search-results{margin-top:12px}

    /* TOC */
    .toc{width:260px;position:sticky;top:22px;height:calc(100vh - 80px);overflow:auto}
    .toc .toc-title{font-size:13px;color:var(--muted);margin-bottom:8px;display:flex;align-items:center;gap:6px}
    .toc .toc-title::before{content:'≡';font-size:12px;color:#9aa4b2}
    .toc a{display:block;padding:6px 10px;color:#374151;text-decoration:none;border-radius:6px;font-size:14px}
    .toc a:hover{background:#f1f5f9}
    .toc a.active{background:linear-gradient(180deg,#e5e7eb,#dcdfe3);color:#111827;font-weight:600;border:1px solid #d1d5db}

    /* markdown body tweaks */
    .markdown-body{background:transparent !important}
    .panel .markdown-body{background:var(--panel) !important}
    .markdown-body img{max-width:100%}
    .markdown-body pre{background:#0b1220;color:#f8fafc;padding:12px;border-radius:8px;overflow:auto;border:1px solid #e6eef8}
    .markdown-body code{background:rgba(15,23,42,0.06);padding:2px 6px;border-radius:6px}
    .hljs{color:#e5e7eb}
    .hljs-keyword,.hljs-selector-tag,.hljs-literal{color:#c792ea}
    .hljs-title,.hljs-name,.hljs-attr{color:#82aaff}
    .hljs-string,.hljs-meta .hljs-string{color:#addb67}
    .hljs-number,.hljs-type{color:#f78c6c}
    .hljs-comment{color:#697386}
    .hljs-built_in,.hljs-builtin-name{color:#ffcb6b}

    /* markdown tables */
    .markdown-body table{width:100%;border-collapse:collapse;margin:12px 0;font-size:14px}
    .markdown-body th,.markdown-body td{border:1px solid #e5e7eb;padding:10px 12px;text-align:left}
    .markdown-body thead th{background:#f8fafc;color:var(--heading)}
    .markdown-body tbody tr:nth-child(odd){background:#fbfdff}
    .markdown-body tbody tr:nth-child(even){background:var(--panel)}

    /* raw markdown view */
    .md-raw{white-space:pre-wrap;word-break:break-word;background:#0b1220;color:#e5e7eb;padding:16px;border-radius:8px;border:1px solid #e6eef8;min-height:200px;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;line-height:1.55}
    .md-raw code{background:transparent;padding:0}

    /* latex.js document overrides */
    .latexjs{background:var(--panel);padding:18px;border-radius:8px;border:1px solid #e6eef8}
    .latexjs h1, .latexjs h2, .latexjs h3{margin-top:1.2em}
    .latexjs p{line-height:1.7;color:#0f172a}
    .latexjs .ltx_page_content{max-width: 840px;margin: 0 auto}

    /* image frames converted from <Frame> */
    .frame{border:1px solid #e6eef8;border-radius:10px;overflow:hidden;margin:14px 0;background:var(--panel)}
    .frame img{display:block;width:100%;height:auto}

    /* responsive */
    @media (max-width:900px){.toc{display:none}.sidebar{display:none}.container{padding:14px}.panel{padding:18px}}

    /* Dark mode via .dark class on html */
    html.dark{
      --bg:#111827;
      --muted:#94a3b8;
      --panel:#1f2937;
      --accent:#22514e08;
      --text:#f3f4f6;
      --nav-text:#f3f4f6;
      --heading:#f3f4f6;
    }
    html.dark .sidebar{background:#0b1220;border-right-color:rgba(255,255,255,0.06)}
    html.dark .nav a{color:#cbd5e1}
    html.dark .nav a.active{background:rgba(139,123,255,0.18);border-left-color:var(--accent)}
    html.dark .folder-title{color:#e5e7eb}
    html.dark .nav .folder-row:hover{background:rgba(255,255,255,0.06)}
    html.dark .topbar{background:linear-gradient(180deg,#0f172a,#0b1220);border-bottom-color:rgba(255,255,255,0.06)}
    html.dark .toc a{color:#b7c3d7}
    html.dark .toc a:hover{background:rgba(255,255,255,0.06)}
    html.dark .toc a.active{background:linear-gradient(180deg,#334155,#1f2937);color:#e5e7eb;border:1px solid #1f2937}
    html.dark .markdown-body pre{background:#0b1325;border-color:#1e293b}
    html.dark .markdown-body code{background:#0b1325;color:#e5e7eb}
    html.dark .markdown-body th, html.dark .markdown-body td{border-color:#2b3443}
    html.dark .markdown-body thead th{background:#121d33;color:#e5e7eb}
    html.dark .markdown-body tbody tr:nth-child(odd){background:#0e162a}
    html.dark .markdown-body tbody tr:nth-child(even){background:#0b1325}
    html.dark .panel{box-shadow:0 8px 28px rgba(0,0,0,0.35)}
    html.dark .search input{background:#0b1320;border-color:#1e293b;color:#e5e7eb}
    html.dark .toggle-btn{background:#0b1320;border-color:#1e293b;color:#e5e7eb}
    html.dark .brand img.logo{filter:none}
    html.dark .markdown-body{color:var(--text);background:transparent}
    html.dark .markdown-body h1,html.dark .markdown-body h2,html.dark .markdown-body h3,html.dark .markdown-body h4,html.dark .markdown-body h5,html.dark .markdown-body h6{color:#e5e7eb}
    html.dark .markdown-body p,html.dark .markdown-body li{color:#cbd5e1}
    html.dark .md-raw{background:#0b1325;border-color:#1e293b;color:#e5e7eb}
    html.dark .latexjs{background:#0f172a;border-color:#1e293b}
    html.dark .latexjs p{color:#cbd5e1}
    html.dark .pdf-frame{border-color:#1e293b}
    html.dark .frame{background:#0f172a;border-color:#1e293b}
    html.dark .pdf-frame{border-color:#1e293b}
    html.dark .top-search input{background:#0b1320;border-color:#1e293b;color:#e5e7eb}
    html.dark .top-search .icon, html.dark .top-search .kbd{color:#94a3b8}
    /* Dark-mode hamburger styling */
    html.dark .brand .hamburger{background:#0b1320;border-color:#1e293b;color:#cbd5e1}
    html.dark .brand .hamburger:hover{background:rgba(255,255,255,0.06)}
    html.dark .brand .hamburger:focus{box-shadow:0 0 0 2px rgba(148,163,184,.35)}
    .doc-footer-nav {
      margin-top: 32px;
      padding-top: 24px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .doc-footer-nav > * {
      width: 100%;
      padding: 12px 0;
    }
    .doc-footer-nav > *:not(:last-child) {
      border-bottom: 1px solid #e5e7eb;
    }
    .feedback {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
      color: var(--muted);
    }
    .feedback-btn {
      background: transparent;
      border: 1px solid #d1d5db;
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .feedback-btn:hover {
      background: #f9fafb;
    }
    .nav-links {
      display: flex;
      justify-content: space-between;
      width: 100%;
      font-size: 14px;
      font-weight: 500;
    }
    .nav-links a {
      color: var(--nav-text);
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .nav-links a:hover {
      text-decoration: underline;
    }
    .footer-github {
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }
    .footer-github img {
      width: 40px;
      height: 40px;
      opacity: 0.8;
      transition: opacity 0.2s ease;
    }
    .footer-github img:hover {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="app">
    <nav class="sidebar" aria-label="Documentation navigation">
      <div class="brand">
        <a class="brand-left" href="/docWebpage/index.html" title="Back to home">
            <img class="logo" src="https://framerusercontent.com/images/ilrJtcE6bZ33SbecrZl2vqXa7w.png?scale-down-to=512" alt=" logo" aria-hidden="true">
            <!-- <h1>SIYA</h1> -->
        </a>
        <button id="collapseBtn" type="button" class="hamburger" title="Toggle sidebar">≡</button>
      </div>
      <div class="nav" id="navList" tabindex="0">Loading docs...</div>
    </nav>

    <main class="main">
      <div class="topbar">
        <div class="left-actions">
          <div class="title">SIYA Documentation</div>
        </div>
        <div class="top-search" role="search">
          <div class="searchbox">
            <span class="icon">🔎</span>
            <input id="quickSearch" type="search" placeholder="Search..." aria-label="Search docs">
            <span class="kbd">⌘K</span>
          </div>
        </div>
        <div class="actions">
          <button id="themeToggle" type="button" class="toggle-btn" title="Toggle theme">🌓</button>
          <a id="openOnGit" class="open-on-git" href="#" target="_blank" rel="noopener">Open on GitHub ↗</a>
        </div>
      </div>

      <div class="container">
        <section class="content">
          <div id="docPanel" class="panel">
            <div class="doc-actions">
              <div class="folder-display"></div>
              <div>
                <button id="copyMd" type="button" class="toggle-btn">Copy page</button>
                <button id="toggleRaw" type="button" class="toggle-btn">View as Markdown</button>
              </div>
            </div>
            <article id="content" class="markdown-body">Loading...</article>
            <div class="doc-footer-nav">
              <div class="feedback">
                <span>Was this page helpful?</span>
                <button class="feedback-btn" data-feedback="yes">👍 Yes</button>
                <button class="feedback-btn" data-feedback="no">👎 No</button>
              </div>
              <div class="nav-links">
                <a id="prevPage" href="#"><span>← </span><strong id="prevTitle"></strong></a>
                <a id="nextPage" href="#"><strong id="nextTitle"></strong><span> →</span></a>
              </div>
              <div class="footer-github">
                <a id="footerGitLink" href="#" target="_blank" title="View this page on GitHub">
                  <img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub logo">
                </a>
              </div>
            </div>
          </div>
        </section>

        <aside class="toc" id="toc" aria-label="Table of contents">
          <div class="toc-inner">
            <div class="toc-title">On this page</div>
            <nav id="tocNav" aria-label="Table of contents list">&nbsp;</nav>
          </div>
        </aside>
      </div>
    </main>
  </div>

  <!-- Search Modal (⌘K) -->
  <div id="searchModal" class="search-modal" hidden>
    <div class="search-panel panel">
      <div class="top-search" role="search">
        <div class="searchbox full">
          <span class="icon">🔎</span>
          <input id="modalSearch" type="search" placeholder="Search for anything…" aria-label="Search docs">
          <span class="kbd">⌘K</span>
        </div>
      </div>
      <div id="searchResults" class="search-results"></div>
    </div>
  </div>

<script>
// Marked.js options: allow HTML and set recommended options
marked.setOptions({
  gfm: true,
  breaks: true,
  headerIds: true,
  mangle: false,
  headerPrefix: '',
  smartLists: true,
  smartypants: false,
  xhtml: false
});
// ========== CONFIG ==========
const repo = 'syia-ai/siya-public-documentation';
let branch = 'main';
const apiBase = `https://api.github.com/repos/${repo}/contents`;
const rawBase = `https://raw.githubusercontent.com/${repo}/`;
// =============================

const navList = document.getElementById('navList');
const repoNameEl = document.getElementById('repoName');
const quickSearch = document.getElementById('quickSearch');
const contentEl = document.getElementById('content');
const pageTitle = document.getElementById('pageTitle');
const folderCrumb = document.getElementById('folderCrumb');
const openOnGit = document.getElementById('openOnGit');
const tocNav = document.getElementById('tocNav');
const searchModal = document.getElementById('searchModal');
const modalSearch = document.getElementById('modalSearch');
const searchResults = document.getElementById('searchResults');
const collapseBtn = document.getElementById('collapseBtn');
const copyMdBtn = document.getElementById('copyMd');
const toggleRawBtn = document.getElementById('toggleRaw');

let files = []; // {name, path, raw_url, title}
// Recommended files: will be set after files are loaded (see bootstrap)
let recommendedFiles = [];
let tree = null; // folder structure
let cache = {}; // path -> {md, html, headings}
let isRawView = false;

// Utility: nice title from filename
  function niceTitle(filename){
  return filename.replace(/\.(md|tex|pdf)$/i,'').replace(/[-_]/g,' ').replace(/\b\w/g, c=>c.toUpperCase());
}

async function detectBranch(){
  for(const b of ['main','master']){
    try{
      const res = await fetch(`https://api.github.com/repos/${repo}/branches/${b}`);
      if(res.ok){ branch = b; return; }
    }catch(e){}
  }
}

async function fetchDirContents(dirPath=""){
  const url = dirPath ? `${apiBase}/${encodeURIComponent(dirPath)}?ref=${branch}` : `${apiBase}?ref=${branch}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('Failed to list repo contents');
  const data = await res.json();
  // NOTE: Do not sort here; preserve GitHub API order
  return data;
}

async function buildTree(dirPath=""){
  const entries = await fetchDirContents(dirPath);
  const node = { name: dirPath || "root", path: dirPath, type: 'dir', children: [] };
  // Preserve order: add files and dirs as they appear in entries
  for(const e of entries){
    if(e.type === 'file' && /\.(md|tex|pdf)$/i.test(e.name)){
      if (e.name.toLowerCase() !== 'readme.md') {
        const fileObj = {name:e.name, path:e.path, raw_url:`${rawBase}${branch}/${e.path}`};
        files.push(fileObj);
        node.children.push({ name: e.name, path: e.path, type: 'file' });
      }
    } else if(e.type === 'dir'){
      // fetch subdir and push it in order
      const st = await buildTree(e.path);
      node.children.push(st);
    }
  }
  return node;
}

async function fetchMarkdown(path){
  if(cache[path] && cache[path].md) return cache[path];
  const file = files.find(f=>f.path===path);
  if(!file) throw new Error('File not found');
  const res = await fetch(file.raw_url);
  if(!res.ok) throw new Error('Failed to fetch file');
  const md = await res.text();
  // preprocess to support MDX-like <Frame> wrappers or images shown inside code blocks
  function preprocessMarkdown(source){
    let s = source;
    // Replace raw <Frame> wrappers with a styled container
    s = s.replace(/<\s*Frame\s*>/gi, '<div class="frame">')
         .replace(/<\s*\/\s*Frame\s*>/gi, '</div>');
    // Convert fenced code blocks that contain <Frame> with <img> into actual images
    s = s.replace(/```[a-zA-Z0-9]*\n([\s\S]*?)```/g, (match, code) => {
      // If fenced block already contains a `div.frame`, just render it as HTML
      if(/<\s*div[^>]*class=["']frame["'][^>]*>/i.test(code)){
        return code.trim();
      }
      // If fenced block includes bare <img>, convert them into framed images
      if(/<\s*img\s+[^>]*src=/i.test(code)){
        const imgs = Array.from(code.matchAll(/<\s*img[^>]*>/gi)).map(m=>m[0]);
        if(imgs.length){
          return imgs.map(tag=>`<div class=\"frame\">${tag}</div>`).join('\n');
        }
      }
      // Render other safe HTML fragments that sometimes appear fenced in the docs
      if(/<\s*(iframe|video|figure|table|section|article)[\s>]/i.test(code)){
        return code.trim();
      }
      return match; // leave normal code blocks untouched
    });
    return s;
  }
  const mdProcessed = preprocessMarkdown(md);
  // marked options already set above globally
  // parse headings using marked lexer
  const isTex = /\.tex$/i.test(file.name);
  const isPdf = /\.pdf$/i.test(file.name);
  let headings = [];
  let html = '';
  if(isPdf){
    // Embed PDF as viewer
    html = `<iframe class=\"pdf-frame\" src=\"${file.raw_url}\" title=\"PDF viewer\"></iframe>`;
    headings = [];
  } else if(isTex){
    // Render full LaTeX document using latex.js for a near-PDF quality HTML view
    try{
      const generator = new latexjs.HtmlGenerator({hyphenate:false});
      latexjs.parse(md, { generator }).htmlDocument();
      const docRoot = generator.domRoot;
      // wrap within a container class for styling
      html = `<div class=\"latexjs\">${docRoot.innerHTML}</div>`;
      // Extract headings from \section/\subsection to build TOC
      const hMatches = Array.from(md.matchAll(/\\(section|subsection)\{([^}]+)\}/g));
      headings = hMatches.map(m=>({ text: m[2], depth: m[1]==='section'?1:2 }));
    }catch(e){
      html = `<pre class=\"md-raw\">${md.replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]))}</pre>`;
    }
  } else {
    const tokens = marked.lexer(mdProcessed);
    headings = tokens.filter(t=>t.type==='heading' && t.depth<=2).map(h=>({text:h.text, depth:h.depth}));
    html = marked.parse(mdProcessed);
    // add subtle container similar to Anthropic docs
    html = `<div style="max-width:840px;margin:0 auto">${html}</div>`;
  }
  cache[path] = {md, html, headings};
  return cache[path];
}

function renderNavTree(node, depth=0){
  const indentClass = depth>0 ? `indent-${Math.min(depth,3)}` : '';
  let html = '';
  if(node.path!=='' && node.type==='dir'){
    const id = `fold-${node.path.replace(/[^a-z0-9]/gi,'_')}`;
    const nameOnly = node.name.split('/').pop();
    html += `<div class="folder-block ${indentClass}">
      <div class="folder-row" data-target="${id}"><span class="folder-title">${niceTitle(nameOnly)}</span><span class="caret">›</span></div>
      <div id="${id}" class="children">`;
  }
  for(const child of node.children){
    if(child.type==='dir'){
      html += renderNavTree(child, depth+1);
    } else {
      // Exclude README.md from navigation
      if(child.name.toLowerCase() !== 'readme.md') {
        // show only leaf name, not full path
        const leaf = child.name.split('/').pop();
        html += `<div class="${indentClass}"><a href="#" data-path="${child.path}">${niceTitle(leaf)}</a></div>`;
      }
    }
  }
  if(node.path!=='' && node.type==='dir'){
    html += `</div></div>`;
  }
  return html;
}

function renderNavFromTree(){
  if(repoNameEl){ repoNameEl.textContent = repo; }
  if(!tree || !tree.children || tree.children.length===0){
    navList.innerHTML = '<div style="padding:12px;color:#6b7280">No documents found.</div>';
    return;
  }
  // --- Begin Vessel Report/FAQ.md order enforcement ---
  // Only adjust the root-level children array
  const rootChildren = tree.children;
  // Move Introduction.md to the top of the list
  const introIndex = rootChildren.findIndex(item => item.type === 'file' && item.name.toLowerCase() === 'introduction.md');
  if (introIndex > 0) {
    const [introItem] = rootChildren.splice(introIndex, 1);
    rootChildren.unshift(introItem);
  }
  const vrIndex = rootChildren.findIndex(item => item.type === 'dir' && item.name.toLowerCase() === 'vessel report');
  const faqIndex = rootChildren.findIndex(item => item.type === 'file' && item.name.toLowerCase() === 'faq.md');
  if (vrIndex !== -1 && faqIndex !== -1 && faqIndex < vrIndex) {
    const [faqItem] = rootChildren.splice(faqIndex, 1);
    rootChildren.splice(vrIndex + 1, 0, faqItem);
  }
  // --- End Vessel Report/FAQ.md order enforcement ---
  // Do NOT sort after this adjustment, to preserve GitHub order.
  const html = renderNavTree(tree, 0);
  navList.innerHTML = `<div style="padding:8px">${html}</div>`;
  // wire folder toggles
  navList.querySelectorAll('.folder-row').forEach(row=>{
    const target = row.getAttribute('data-target');
    const body = document.getElementById(target);
    const caret = row.querySelector('.caret');
    if(caret){
      // ensure all folders are collapsed by default
      if(body) body.style.display = 'none';
      row.classList.add('collapsed');
      // If <details> element is ever used, ensure .open = false
      // (not used in HTML here, but for future-proofing)
      // If you switch to <details>, set detailsEl.open = false;
      caret.addEventListener('click', (e)=>{
        e.stopPropagation();
        const collapsed = row.classList.toggle('collapsed');
        if(collapsed){ body.style.display='none'; } else { body.style.display='block'; }
      });
    }
  });
  navList.querySelectorAll('a').forEach(a=>a.addEventListener('click', async e=>{
    e.preventDefault();
    const path = a.dataset.path;
    await openDoc(path);
    navList.querySelectorAll('a').forEach(x=>x.classList.remove('active'));
    a.classList.add('active');
  }));
}

// Sanitize heading text for TOC display (strip markdown/emojis/extra symbols)
function sanitizeForTOC(text){
  if(!text) return '';
  let t = text;
  t = t.replace(/!\[[^\]]*\]\([^)]*\)/g, '');        // remove images
  t = t.replace(/\[([^\]]+)\]\([^)]*\)/g, '$1');      // links -> text
  t = t.replace(/`([^`]+)`/g, '$1');                      // inline code
  t = t.replace(/[\*_~]+/g, '');                         // emphasis markers
  t = t.replace(/<[^>]+>/g, '');                          // html tags
  t = t.replace(/^[^A-Za-z0-9]+/, '');                    // leading emojis/symbols
  t = t.replace(/\s+/g, ' ').trim();
  return t;
}

function renderTOC(headings){
  if(!headings || headings.length===0){ tocNav.innerHTML = '<div style="color:#9ca3af">No headings</div>'; return; }
  tocNav.innerHTML = headings.map(h=>`<a href="#" data-id="${slug(h.text)}" style="padding-left:${(h.depth-1)*10}px">${sanitizeForTOC(h.text)}</a>`).join('');
  tocNav.querySelectorAll('a').forEach(a=>a.addEventListener('click', e=>{
    e.preventDefault();
    const id = a.dataset.id;
    const el = document.getElementById(id);
    if(el){ el.scrollIntoView({behavior:'smooth',block:'center'}); history.replaceState(null,'',`#${encodeURIComponent(currentPath)}:${id}`); }
  }));
}

function slug(text){
  return text.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
}

let currentPath = null;

function updatePrevNextLinks(path) {
  const index = files.findIndex(f => f.path === path);
  const prev = files[index - 1];
  const next = files[index + 1];

  const prevLink = document.getElementById('prevPage');
  const nextLink = document.getElementById('nextPage');
  const prevTitle = document.getElementById('prevTitle');
  const nextTitle = document.getElementById('nextTitle');

  if (prev) {
    prevLink.style.display = 'inline-flex';
    prevLink.dataset.path = prev.path;
    prevTitle.textContent = niceTitle(prev.name);
  } else {
    prevLink.style.display = 'none';
  }

  if (next) {
    nextLink.style.display = 'inline-flex';
    nextLink.dataset.path = next.path;
    nextTitle.textContent = niceTitle(next.name);
  } else {
    nextLink.style.display = 'none';
  }
}

document.addEventListener('click', async (e) => {
  if (e.target.closest('#prevPage') || e.target.closest('#nextPage')) {
    e.preventDefault();
    const path = e.target.closest('a').dataset.path;
    if (path) await openDoc(path);
  }
});

async function openDoc(path){
  currentPath = path;
  // Update folder display inside panel only; keep header as just brand
  const parts = path.split('/');
  const folder = parts.length > 1 ? parts[parts.length - 2] : '';
  const folderName = folder ? niceTitle(folder) : 'Root';
  document.querySelector('.folder-display').textContent = folderName;
  if(folderCrumb){ folderCrumb.textContent = ''; }
  openOnGit.href = `https://github.com/${repo}/blob/${branch}/${path}`;
  // --- Set the markdown viewer's top title/breadcrumb as per the new logic ---
  const filePath = path;
  {
    const parts = filePath.split('/');
    let displayTitle;
    if (parts.length === 1) {
      // Root-level file: only show filename without .md
      displayTitle = parts[0].replace(/\.md$/i, '');
    } else {
      // Show folder / filename without .md
      displayTitle = parts.slice(-2).join(' / ').replace(/\.md$/i, '');
    }
    // Find the element to set. Try id="docTitle" first, fallback to #pageTitle if needed.
    const docTitleEl = document.getElementById('docTitle') || document.getElementById('pageTitle');
    if (docTitleEl) docTitleEl.textContent = displayTitle;
  }
  contentEl.innerHTML = '<div style="padding:20px;color:#6b7280">Loading document…</div>';
  try{
    // If the file is markdown, render using marked.parse to allow HTML
    const file = files.find(f=>f.path===path);
    if (file && /\.md$/i.test(file.name)) {
      // Fetch and render markdown using marked with HTML allowed
      const mdContent = await fetch(file.raw_url).then(res => res.text());
      // Preprocess as in fetchMarkdown
      let s = mdContent;
      s = s.replace(/<\s*Frame\s*>/gi, '<div class="frame">')
           .replace(/<\s*\/\s*Frame\s*>/gi, '</div>');
      s = s.replace(/```[a-zA-Z0-9]*\n([\s\S]*?)```/g, (match, code) => {
        if(/<\s*div[^>]*class=["']frame["'][^>]*>/i.test(code)){
          return code.trim();
        }
        if(/<\s*img\s+[^>]*src=/i.test(code)){
          const imgs = Array.from(code.matchAll(/<\s*img[^>]*>/gi)).map(m=>m[0]);
          if(imgs.length){
            return imgs.map(tag=>`<div class=\"frame\">${tag}</div>`).join('\n');
          }
        }
        if(/<\s*(iframe|video|figure|table|section|article)[\s>]/i.test(code)){
          return code.trim();
        }
        return match;
      });
      // Render markdown to HTML using marked, which now allows HTML
      contentEl.innerHTML = `<div id="markdownContainer" style="max-width:840px;margin:0 auto">${marked.parse(s)}</div>`;
      // Ensure iframes inside markdown render full width and with default height
      document.querySelectorAll('#markdownContainer iframe').forEach(iframe => {
        iframe.style.width = '100%';
        iframe.style.minHeight = '600px';
        iframe.style.border = '1px solid #ddd';
        iframe.style.overflow = 'auto';
      });
      // Ensure headings have predictable IDs for TOC linking
      contentEl.querySelectorAll('h1,h2,h3').forEach(h=>{
        const id = slug(h.textContent || h.innerText);
        h.id = id;
      });
      // Re-run math renderers for dynamically injected content
      try{
        if(window.renderMathInElement){
          window.renderMathInElement(contentEl, {
            delimiters: [
              { left: '$$', right: '$$', display: true },
              { left: '$', right: '$', display: false },
              { left: '\\(', right: '\\)', display: false },
              { left: '\\[', right: '\\]', display: true }
            ]
          });
        }
        if(window.MathJax && MathJax.typesetPromise){
          MathJax.typesetPromise([contentEl]).catch(()=>{});
        }
      }catch(_){}
      document.querySelectorAll('pre code').forEach(block=>hljs.highlightElement(block));
      // Headings for TOC
      const tokens = marked.lexer(s);
      const headings = tokens.filter(t=>t.type==='heading' && t.depth<=2).map(h=>({text:h.text, depth:h.depth}));
      const fileHeading = file ? [{ text: file.name.replace(/\.(md|tex)$/i,'') , depth: 2 }] : [];
      renderTOC([...fileHeading, ...headings]);
      if(toggleRawBtn) toggleRawBtn.textContent = 'View as Markdown';
      // deep link to heading if present in URL
      const hash = decodeURIComponent(location.hash.slice(1));
      if(hash){
        if(hash.startsWith(encodeURIComponent(path)+':')){
          const parts = hash.split(':');
          const h = parts[1];
          const el = document.getElementById(h);
          if(el) setTimeout(()=>el.scrollIntoView({behavior:'smooth',block:'center'}),200);
        }
      }
      // update history
      history.replaceState(null,'',`#${encodeURIComponent(path)}`);
      updatePrevNextLinks(path);
      const footerGitLink = document.getElementById('footerGitLink');
      if (footerGitLink) {
        footerGitLink.href = `https://github.com/syia-ai/siya-public-documentation`;
      }
      return;
    }
    // Fallback to original fetchMarkdown for .tex/.pdf/etc
    const {html, headings} = await fetchMarkdown(path);
    // insert HTML and ensure headings have predictable IDs for TOC linking
    // marked already sets header ids, but ensure they match our slug
    const doc = document.createElement('div');
    doc.innerHTML = html;
    // rewrite h1-h3 ids
    doc.querySelectorAll('h1,h2,h3').forEach(h=>{
      const id = slug(h.textContent || h.innerText);
      h.id = id;
    });
    contentEl.innerHTML = '';
    if(isRawView){
      // show raw markdown instead
      const raw = document.createElement('pre');
      raw.className = 'md-raw';
      raw.textContent = cache[path]?.md || '';
      contentEl.appendChild(raw);
      renderTOC([]);
      if(toggleRawBtn) toggleRawBtn.textContent = 'View as Rendered';
    } else {
      contentEl.appendChild(doc);
      // Re-run math renderers for dynamically injected content
      try{
        if(window.renderMathInElement){
          window.renderMathInElement(doc, {
            delimiters: [
              { left: '$$', right: '$$', display: true },
              { left: '$', right: '$', display: false },
              { left: '\\(', right: '\\)', display: false },
              { left: '\\[', right: '\\]', display: true }
            ]
          });
        }
        if(window.MathJax && MathJax.typesetPromise){
          MathJax.typesetPromise([doc]).catch(()=>{});
        }
      }catch(_){}
      document.querySelectorAll('pre code').forEach(block=>hljs.highlightElement(block));
      // ensure our prepended H2 is also shown in TOC as first item
      const f = files.find(f=>f.path===path);
      const fileHeading = f ? [{ text: f.name.replace(/\.(md|tex)$/i,'') , depth: 2 }] : [];
      renderTOC([...fileHeading, ...headings]);
      if(toggleRawBtn) toggleRawBtn.textContent = 'View as Markdown';
    }
    // deep link to heading if present in URL
    const hash = decodeURIComponent(location.hash.slice(1));
    if(hash){
      if(hash.startsWith(encodeURIComponent(path)+':')){
        const parts = hash.split(':');
        const h = parts[1];
        const el = document.getElementById(h);
        if(el) setTimeout(()=>el.scrollIntoView({behavior:'smooth',block:'center'}),200);
      }
    }
    // update history
    history.replaceState(null,'',`#${encodeURIComponent(path)}`);
    updatePrevNextLinks(path);
    const footerGitLink = document.getElementById('footerGitLink');
    if (footerGitLink) {
      footerGitLink.href = `https://github.com/syia-ai/siya-public-documentation`;
    }
  }catch(e){ contentEl.innerHTML = `<div style="color:#ef4444">Error loading document: ${e.message}</div>`; }
}

// --- Recommendation and Search UI helpers ---
function getRandomRecommendations() {
  const mdFiles = files.filter(f =>
    f.name.toLowerCase().endsWith('.md') &&
    f.name.toLowerCase() !== 'readme.md'
  );
  const shuffled = mdFiles.sort(() => 0.5 - Math.random());
  return shuffled.slice(0, 3);
}

function showResults(list, isRecommendation = false) {
  const container = document.getElementById('searchResults');
  container.innerHTML = '';

  if (isRecommendation) {
    const label = document.createElement('div');
    label.textContent = 'Recent searches';
    label.style.fontSize = '13px';
    label.style.fontWeight = '600';
    label.style.padding = '6px 12px';
    label.style.color = '#555';
    container.appendChild(label);
  }

  if (!list.length) {
    container.innerHTML += '<div style="padding:8px 12px;color:#888">No match</div>';
    return;
  }

  list.forEach(f => {
    const item = document.createElement('div');
    item.style.padding = '8px 12px';
    item.style.cursor = 'pointer';
    item.style.fontSize = '14px';
    item.style.display = 'flex';
    item.style.flexDirection = 'column';
    item.style.borderBottom = '1px solid #f0f0f0';

    const pathDiv = document.createElement('div');
    pathDiv.textContent = f.path.replace(/\.md$/i, '');
    pathDiv.style.fontSize = '12px';
    pathDiv.style.color = '#6b7280';

    const title = document.createElement('div');
    title.textContent = f.name.replace(/\.md$/i, '');
    title.style.fontSize = '15px';
    title.style.color = '#111';
    title.style.fontWeight = '500';
    title.style.marginTop = '2px';

    item.appendChild(pathDiv);
    item.appendChild(title);

    item.addEventListener('mouseover', () => {
      item.style.background = '#f3f4f6';
    });
    item.addEventListener('mouseout', () => {
      item.style.background = '';
    });
    item.addEventListener('click', async (e) => {
      e.preventDefault();
      try { closeSearchModal(); } catch(_) {}
      await openDoc(f.path);
      const el = navList.querySelector(`a[data-path='${f.path}']`);
      if (el) {
        navList.querySelectorAll('a').forEach(x => x.classList.remove('active'));
        el.classList.add('active');
      }
    });

    container.appendChild(item);
  });
}

// Search: across filenames & headings (lazy headings loaded)
let searchTimer = null;
quickSearch.addEventListener('input', function () {
  const query = this.value.trim().toLowerCase();

  if (!query) {
    showResults(getRandomRecommendations(), true);
    return;
  }

  const results = files.filter(f =>
    f.name.toLowerCase().endsWith('.md') &&
    f.name.toLowerCase() !== 'readme.md' &&
    f.name.toLowerCase().includes(query)
  );
  showResults(results);
});

// also open modal when clicking the header search box
if(quickSearch){
  quickSearch.addEventListener('focus', ()=>{
    // Open modal on focus to match ⌘K behavior
    openSearchModal();
    // mirror the current value
    modalSearch.value = quickSearch.value;
    modalSearch.dispatchEvent(new Event('input'));
    // Show recommended files when search opens
    showResults(getRandomRecommendations(), true);
  });
}

// Unified search used by both header input and modal
async function searchFiles(query){
  const q = query.trim().toLowerCase();
  if(!q) return recommendedFiles;
  const byName = files.filter(f=>niceTitle(f.name.replace(/\.(md|tex|pdf)$/i,'')).toLowerCase().includes(q));
  const byHeading = [];
  await Promise.all(files.map(async f=>{
    const cached = cache[f.path];
    if(cached && cached.headings){
      if(cached.headings.some(h=>h.text.toLowerCase().includes(q))) byHeading.push(f);
    } else {
      try{ const c = await fetchMarkdown(f.path); if(c.headings.some(h=>h.text.toLowerCase().includes(q))) byHeading.push(f); }catch(e){}
    }
  }));
  const combined = [...new Map([...byName, ...byHeading].map(i=>[i.path,i])).values()];
  combined.sort((a,b)=>niceTitle(a.name).localeCompare(niceTitle(b.name)));
  return combined;
}

// ⌘K modal behavior
function openSearchModal(){
  searchModal.removeAttribute('hidden');
  setTimeout(()=>modalSearch.focus(), 0);
  // Show recommended files when modal opens
  showResults(getRandomRecommendations(), true);
}
function closeSearchModal(){
  searchModal.setAttribute('hidden','');
}
document.addEventListener('keydown', (e)=>{
  if((e.metaKey || e.ctrlKey) && e.key.toLowerCase()==='k'){
    e.preventDefault();
    openSearchModal();
  } else if(e.key==='Escape' && !searchModal.hasAttribute('hidden')){
    closeSearchModal();
  }
});
searchModal.addEventListener('click', (e)=>{ if(e.target===searchModal) closeSearchModal(); });

// (old showResults function replaced above)

modalSearch.addEventListener('input', function () {
  const query = this.value.trim().toLowerCase();

  if (!query) {
    showResults(getRandomRecommendations(), true);
    return;
  }

  const results = files.filter(f =>
    f.name.toLowerCase().endsWith('.md') &&
    f.name.toLowerCase() !== 'readme.md' &&
    f.name.toLowerCase().includes(query)
  );
  showResults(results);
});

// Theme toggle (avoid naming collision with element id -> use a different JS variable name)
const themeToggleBtn = document.getElementById('themeToggle');
function applyTheme(theme){
  const isDark = theme === 'dark';
  document.documentElement.classList.toggle('dark', isDark);
  try{ localStorage.setItem('theme', isDark ? 'dark' : 'light'); }catch(e){}
}
function toggleTheme(){
  const isDark = document.documentElement.classList.contains('dark');
  applyTheme(isDark ? 'light' : 'dark');
}
if(themeToggleBtn){
  themeToggleBtn.addEventListener('click', toggleTheme);
} else {
  // Defensive: if element isn't present, don't crash
  console.warn('Theme toggle button not found');
}

// Sidebar collapse control
if(collapseBtn){
  collapseBtn.addEventListener('click', ()=>{
    document.querySelector('.app').classList.toggle('collapsed');
  });
}

async function copyCurrentMarkdown(){
  try{
    if(!currentPath) return;
    const data = cache[currentPath] || await fetchMarkdown(currentPath);
    await navigator.clipboard.writeText(data.md || '');
    if(copyMdBtn){
      const originalText = copyMdBtn.textContent;
      copyMdBtn.disabled = true;
      copyMdBtn.textContent = 'Copied ✓';
      copyMdBtn.classList.add('copied');
      setTimeout(()=>{
        copyMdBtn.disabled = false;
        copyMdBtn.textContent = originalText;
        copyMdBtn.classList.remove('copied');
      }, 2000);
    }
  }catch(e){ console.warn('Copy failed', e); }
}
function toggleRawView(){
  isRawView = !isRawView;
  if(currentPath) openDoc(currentPath);
}
if(copyMdBtn){ copyMdBtn.addEventListener('click', copyCurrentMarkdown); }
if(toggleRawBtn){ toggleRawBtn.addEventListener('click', toggleRawView); }

// Boot
// Remove README.md from files globally after fetching
(async function bootstrap(){
  try{
    // initialize theme from storage or system preference
    try{
      const saved = localStorage.getItem('theme');
      if(saved === 'dark' || saved === 'light'){
        applyTheme(saved);
      } else if(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches){
        applyTheme('dark');
      }
    }catch(e){}
    await detectBranch();
    tree = await buildTree("");
    // files already filled in buildTree; keep original order from GitHub
    // Remove README.md from files globally for navigation, search, and recommendations
    files = files.filter(f => f.name.toLowerCase() !== 'readme.md');
    // Set recommendedFiles to first 3 files for default suggestions
    recommendedFiles = files.slice(0, 3);
    renderNavFromTree();
    // auto open README if present, else first file
    const readme = files.find(f=>/readme\.md$/i.test(f.name));
    const hash = decodeURIComponent(location.hash.slice(1));
    if(hash){
      // If hash corresponds to path:heading or just path
      const decoded = hash;
      if(decoded.includes(':')){
        const parts = decoded.split(':');
        const p = decodeURIComponent(parts[0]);
        if(files.some(f=>f.path===p)) await openDoc(p);
      } else {
        const p = decodeURIComponent(decoded);
        if(files.some(f=>f.path===p)) await openDoc(p);
      }
    } else if(readme) {
      await openDoc(readme.path);
      // mark active nav
      const el = navList.querySelector(`a[data-path='${readme.path}']`);
      if(el) el.classList.add('active');
    } else if(files[0]){ await openDoc(files[0].path); const el = navList.querySelector(`a[data-path='${files[0].path}']`); if(el) el.classList.add('active'); }
  }catch(e){ navList.innerHTML = `<div style="padding:12px;color:#ef4444">Failed to load repo: ${e.message}</div>`; }
})();

</script>
</body>
</html>

